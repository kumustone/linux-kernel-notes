# linux文件管理

## 虚拟文件系统

[linux文件系统详解](https://blog.csdn.net/freeking101/article/details/78223455)



![image-20180425165716332](image-20180425165716332.png)



![image-20180426104547721](image-20180426104547721.png)



查看系统调用表：

[linux系统调用表](https://blog.csdn.net/sinat_26227857/article/details/44244433)



fd -> struct *file -> inode -> 文件实体

1. 通过fd是如何找到struct *file的？

   - 没有运行的进程都保持一个struct *file 的数组，fd就是这个数组的下标，即通过fd可以直接寻址struct *file;

   ![image-20180426144440782](image-20180426144440782.png)

2. 通过struct *file如何找到这个文件的inode？

    函数调用中是在open的时候，就放到struct *file, 中间的调用层次很深；要查找的数据结构是在内核中的，不是属于某一个进程；

了解了以上两点：

1. 写操作是系统调用，由内核负责的原子操作，所以不会出现相互交叉的情况，比如“AAAA", "BBBB", 写入的文件不会出现”AABBAABB"的情况，但是写是可以相互覆盖的；
2. 两个不同的fd指向同一个文件（不同进程打开）

- write的时候如果存在lseek操作，可能写之间会相互覆盖。
- 如果要避免上述情况的发生，则采用O_APPEND的方式

1. 同一个进程，多线程使用同一个fd

只有一个文件表项，也就是只有一个文件偏移量，如果不需要调用lseek()后再调用read()/write()，那么并没有数据冲突的危险; 如果存在lseek的情况，同情况1；

​

## 页高速缓存和页回写

如何设计这样的缓存？

**缓存的时机是什么**

缓存 -> 磁盘

有三种解决方案：

- 不做缓存，直接写入磁盘。这样效率无疑是非常低的。
- 写透缓存。自动更新内存缓存，同时更新磁盘文件。
- 回写。更新缓存，并把页面标记为脏，加入到脏页链表当中，然后由一个进程周期性写回到磁盘中。（读的时候，直接降其读出来就行了）

**缓存的退出机制是怎样的**

- 最近最少使用（已经不错了，还是有缺陷，比如有的人只加载了一次就不用了）
- 双链策略；（活跃缓存和非活跃缓存，向上面那种情况，只有一次放入到非活跃链表中）



## mmap

参考：

[认真分析mmap：是什么 为什么 怎么用](http://www.cnblogs.com/huxiao-tee/p/4660352.html)

**mmap是干什么的**

mmap是一中内存映射文件的方法，即将一个文件或者其它对象映射到进程空间，实现文件磁盘地址和进程虚拟地址空间一一映射的关系。

![image-20180410163155420](image-20180410163155420.png)

**kernel 映射过程**

- 当前进程的地址空间中，寻找一段空闲的，满足要求的虚拟区。

- 分配一个vm_area_struct来描述和管理这段内存区域，并vm_area_struct插入到进程的虚拟地址区域链表或者树中。

- 使用下面的函数，把“文件”和”内存“关联起来

  > int mmap(struct file *filp, struct vm_area_struct *vma)

  注意这个时候，虚拟地址并没有任何数据关联到主存中。实际上“物理磁盘” -> "内存"过程还是按需缓存的。

- 进程发起对这篇映射空间的访问，引发缺页异常，实现文件内容到物理内存的拷贝；

  a)进程读写这一段区域 -> 查询页表（没有） -> 缺页异常。b)在swap cache中寻找（没有)-> nopage -> 从磁盘装入到主存中。

**与常规文件操作有何优点？**

- 常规文件操作需要从`磁盘操作`->`页缓存`->`用户主存` 两次数据拷贝。而mmap只要`磁盘操作`->`页缓存`两步操作。
- 提供进程间共享内存及相互通信的方式。对于父子进程或者亲缘进程，由于可以感知到彼此的虚拟内存区域，都可以将自身用户空间映射到同一个文件或者匿名映射到同一片区域。

**评论**

1. linux是否称文件描述符比“句柄”更佳。
2. mmap之所以快，是因为建立了页到用户进程的虚地址空间映射，以读取文件为例，避免了页从内核态拷贝到用户态。
3. 除第2点之外，mmap映射的页和其它的页并没有本质的不同。
   所以得益于主要的3种数据结构的高效，其页映射过程也很高效：
   (1) radix tree，用于查找某页是否已在缓存.
   (2) red black tree ，用于查找和更新vma结构。
   (3) 双向链表，用于维护active和inactive链表，支持LRU类算法进行内存回收。
4. mmap不是银弹
   (1) 对变长文件不适合。
   (2) 如果更新文件的操作很多，mmap避免两态拷贝的优势就被摊还，最终还是落在了大量的脏页回写及由此引发的随机IO上。

所以在随机写很多的情况下，mmap方式在效率上不一定会比带缓冲区的一般写快。

1. 之前接触的mongodb版本无法控制对内存的使用，所以当数据比较大时，其内存使用难以控制，一切的内存 -> 页 -> swap 步骤都交给了操作系统，难以进行有效调优。频繁的页swap会让mongodb的优势荡然无从。

